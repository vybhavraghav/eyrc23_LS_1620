#python

###### GLOBAL VARIABLES HERE ######
base = None
motor = None
arm = None
pendulum = None
U = None
e1 = 0
e2 = 0
Vp= 0 
Va = 0
I1=0
I2=0
Ki1=10
Ki2=1

# You can add variables here 
# as required by your implementation.
###################################

def sysCall_init():
    # do some initialization here
    # This function will be executed once when the simulation starts
    
    ####### ADD YOUR CODE HERE ######
    # Hint: Initialize the scene objects which you will require 
    #       Initialize algorithm related variables here
    
    #################################
    global base, motor, arm, pendulum, elbow, U, pivot
    base = sim.getObjectHandle("Base_B")
    pivot = sim.getObjectHandle("Pivot_B")
    motor = sim.getObjectHandle("Elbow_motor_B")
    arm = sim.getObjectHandle("Arm_B")
    print(sim.getObjectAliasRelative(arm ,base))
    pendulum = sim.getObjectHandle("Pendulum_B")
    elbow= sim.getObjectHandle("./Arm_B/Elbow_free_B")
    U = 0
    pass


def sysCall_actuation():
    # put your actuation code here
    # This function will be executed at each simulation time step

    ####### ADD YOUR CODE HERE ######
    # Hint: Use the error feedback and apply control algorithm here
    #       Provide the resulting actuation as input to the actuator joint
    
    # Example psuedo code:
    #   x1 = error_state_1; # Error in states w.r.t desired setpoint
    #   x2 = error_state_2;
    #   x3 = error_state_3;
    #   x4 = error_state_4;
    #   k = [gain_1 , gain_1, gain_3, gain_4];      # These gains will be generated by control algorithm. For ex: LQR, PID, etc.
    #   U = -k[1]*x1 +k[2]*x2 -k[3]*x3 +k[4]*x4;    # +/- Sign convention may differ according to implementation
    #   Set_joint_actuation(U);                     # Provide this calculated input to system's actuator

    #################################
    global e1, e2, Vp, Va, Ki1, Ki2, I1, I2
    kp1 =100
    kp2 = 50
    kd1 = 0.5
    kd2 = 0
 

    U = kp1*e1 +kp2*e2 - kd1*Vp - kd2*Va+ I1+I2
   # print(U)
    
    sim.setJointTargetVelocity(motor, 4*U)
    pass

def sysCall_sensing():
    # put your sensing code here
    # This function will be executed at each simulation time step
    
    ####### ADD YOUR CODE HERE ######
    # Hint: Take feedback here & do the error calculation
    
    #################################
        #################################
    global elbow, motor, e1, e2 , Vp,Va ,pivot,I1,I2,Ki1, Ki2, dt

    dt=sim.getSimulationTime()
    t = sim.getJointPosition(elbow)
    a = sim.getJointPosition(pivot)
    print("t")
    print(t)
    print("a")
    print(a)
    Vp = sim.getJointVelocity(elbow)
    Va= sim.getJointVelocity(pivot)
    e1 = t
    e2 = a
    I1=(I1 + Ki1*dt*e1)
    I2=(I2 + Ki2*dt*e2)
    pass

def sysCall_cleanup():
    # do some clean-up here
    # This function will be executed when the simulation ends
    
    ####### ADD YOUR CODE HERE ######
    # Any cleanup (if required) to take the scene back to it's original state after simulation
    # It helps in case simulation fails in an unwanted state.

    pass
    pass

# See the user manual or the available code snippets for additional callback functions and details
